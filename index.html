<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Color Picker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            overflow-x: hidden; /* Prevent horizontal scroll on small screens */
        }
        .container {
            max-width: 90%; /* Responsive width */
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 1rem; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Softer shadow */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .upload-area {
            border: 2px dashed #d1d5db; /* Light gray dashed border */
            border-radius: 0.75rem;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin-bottom: 1.5rem; /* Add some space below upload area */
        }
        .upload-area:hover {
            border-color: #9ca3af; /* Darker gray on hover */
            background-color: #f9fafb;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* Max width for canvas */
            margin-top: 0; /* Removed redundant margin-top */
            border-radius: 0.75rem;
            overflow: hidden; /* Ensure canvas corners are rounded */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        canvas {
            display: block;
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            border-radius: 0.75rem;
        }
        .color-display-area {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.75rem;
            padding: 1rem 1.5rem;
            margin-top: 1.5rem;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }
        .color-box {
            width: 6rem;
            height: 6rem;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            margin: 0 auto 1rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        .copy-button {
            background-color: #4f46e5; /* Indigo */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
            font-weight: 500;
        }
        .copy-button:hover {
            background-color: #4338ca; /* Darker indigo */
        }
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #10b981; /* Green for success */
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .message-box.show {
            opacity: 1;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.75rem;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        .loading-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Magnifier styles */
        #magnifier {
            position: absolute; /* Reverted to absolute for canvas-relative positioning */
            width: 120px; /* Size of the magnifier */
            height: 120px;
            border: 2px solid #4f46e5; /* Indigo border */
            border-radius: 50%; /* Circular magnifier */
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
            pointer-events: none; /* Important: allows mouse events to pass through to the canvas below */
            display: none; /* Hidden by default */
            z-index: 999; /* Ensure it's above the canvas */
            background-color: white; /* Fallback background */
        }
        #magnifierCanvas {
            width: 100%;
            height: 100%;
            display: block;
            /* Crucial for pixelated scaling */
            image-rendering: optimizeSpeed; /* Older Safari */
            image-rendering: -webkit-optimize-contrast; /* Safari, Chrome */
            image-rendering: -moz-crisp-edges; /* Firefox */
            image-rendering: pixelated; /* Modern browsers */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                max-width: 95%;
                padding: 1rem;
            }
            .color-display-area {
                padding: 0.75rem 1rem;
            }
            .color-box {
                width: 4rem;
                height: 4rem;
            }
            .text-3xl { /* Adjust heading size for smaller screens */
                font-size: 2rem;
            }
            #magnifier {
                width: 100px; /* Smaller magnifier on mobile */
                height: 100px;
            }
        }
    </style>
</head>
<body class="antialiased">
    <div class="container">
        <h1 class="text-3xl font-bold text-gray-800 mb-6">Image Color Picker</h1>

        <label for="imageUpload" class="upload-area w-full md:w-3/4 lg:w-1/2">
            <input type="file" id="imageUpload" accept="image/*" class="hidden">
            <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
            </svg>
            <p class="mt-2 text-sm text-gray-600">Drag and drop an image here, or click to select a file</p>
            <p class="text-xs text-gray-500 mt-1">(PNG, JPG, JPEG, GIF)</p>
        </label>

        <div class="canvas-container relative">
            <canvas id="imageCanvas" class="cursor-crosshair"></canvas>
            <div id="loadingOverlay" class="loading-overlay">
                <div class="spinner"></div>
            </div>
            <div id="magnifier">
                <canvas id="magnifierCanvas"></canvas>
            </div>
        </div>

        <div class="color-display-area flex flex-col items-center">
            <div id="colorBox" class="color-box mb-4" style="background-color: #ccc;"></div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 w-full">
                <div class="flex flex-col items-center">
                    <p class="text-sm font-medium text-gray-700">Hex</p>
                    <div class="flex items-center space-x-2 mt-1">
                        <span id="hexValue" class="text-lg font-semibold text-gray-900">#------</span>
                        <button class="copy-button text-xs" onclick="copyToClipboard('hexValue')">Copy</button>
                    </div>
                </div>
                <div class="flex flex-col items-center">
                    <p class="text-sm font-medium text-gray-700">RGB</p>
                    <div class="flex items-center space-x-2 mt-1">
                        <span id="rgbValue" class="text-lg font-semibold text-gray-900">rgb(---,---,---)</span>
                        <button class="copy-button text-xs" onclick="copyToClipboard('rgbValue')">Copy</button>
                    </div>
                </div>
                <div class="flex flex-col items-center">
                    <p class="text-sm font-medium text-gray-700">HSL</p>
                    <div class="flex items-center space-x-2 mt-1">
                        <span id="hslValue" class="text-lg font-semibold text-gray-900">hsl(---,---%,---%)</span>
                        <button class="copy-button text-xs" onclick="copyToClipboard('hslValue')">Copy</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box"></div>

    <script>
        // Get references to DOM elements
        const imageUpload = document.getElementById('imageUpload');
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const colorBox = document.getElementById('colorBox');
        const hexValue = document.getElementById('hexValue');
        const rgbValue = document.getElementById('rgbValue');
        const hslValue = document.getElementById('hslValue');
        const messageBox = document.getElementById('messageBox');
        const loadingOverlay = document.getElementById('loadingOverlay');

        // Magnifier elements
        const magnifier = document.getElementById('magnifier');
        const magnifierCanvas = document.getElementById('magnifierCanvas');
        const magnifierCtx = magnifierCanvas.getContext('2d');

        // Magnifier settings
        const MAGNIFIER_SIZE = 120; // Width and height of the magnifier
        const MAGNIFICATION_FACTOR = 4; // How much to magnify (e.g., 4x zoom)
        const SOURCE_REGION_SIZE = MAGNIFIER_SIZE / MAGNIFICATION_FACTOR; // Size of the area to sample from the main canvas

        let currentImage = null; // Store the loaded image object

        // Set magnifier canvas dimensions
        magnifierCanvas.width = MAGNIFIER_SIZE;
        magnifierCanvas.height = MAGNIFIER_SIZE;

        // Crucial: Disable image smoothing for the magnifier context to get pixelated effect
        magnifierCtx.imageSmoothingEnabled = false;
        magnifierCtx.mozImageSmoothingEnabled = false; /* Firefox */
        magnifierCtx.webkitImageSmoothingEnabled = false; /* Safari */
        magnifierCtx.msImageSmoothingEnabled = false; /* IE */


        // Function to show a temporary message
        function showMessage(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = `message-box show ${type === 'success' ? 'bg-green-500' : 'bg-red-500'}`;
            setTimeout(() => {
                messageBox.className = 'message-box';
            }, 2000);
        }

        // Function to show/hide loading overlay
        function showLoading(show) {
            if (show) {
                loadingOverlay.classList.add('show');
            } else {
                loadingOverlay.classList.remove('show');
            }
        }

        // Event listener for image file upload
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                showLoading(true); // Show loading spinner
                const reader = new FileReader();

                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        currentImage = img; // Store the image
                        drawImageOnCanvas(img);
                        showLoading(false); // Hide loading spinner
                    };
                    img.onerror = () => {
                        showMessage('Error loading image. Please try another file.', 'error');
                        showLoading(false);
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    showMessage('Error reading file. Please try again.', 'error');
                    showLoading(false);
                };
                reader.readAsDataURL(file);
            }
        });

        // Function to draw image on canvas and adjust canvas size
        function drawImageOnCanvas(img) {
            // Set canvas dimensions to match image, maintaining aspect ratio
            const maxWidth = imageCanvas.parentElement.clientWidth; // Get parent width for responsiveness
            const maxHeight = window.innerHeight * 0.7; // Max height to prevent excessively tall images

            let width = img.width;
            let height = img.height;

            // Adjust dimensions if image is larger than max width/height
            if (width > maxWidth) {
                height = height * (maxWidth / width);
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = width * (maxHeight / height);
                height = maxHeight;
            }

            imageCanvas.width = width;
            imageCanvas.height = height;

            // Clear canvas before drawing new image
            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            ctx.drawImage(img, 0, 0, imageCanvas.width, imageCanvas.height);
        }

        // Function to get pixel color from canvas and update magnifier
        function getPixelColorAndMagnify(event) {
            if (!currentImage) {
                magnifier.style.display = 'none'; // Hide magnifier if no image
                return;
            }

            // Get mouse coordinates relative to the canvas
            const rect = imageCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Ensure coordinates are within canvas bounds
            // Round to nearest integer to get the exact pixel under the cursor
            const clampedX = Math.round(Math.max(0, Math.min(x, imageCanvas.width - 1)));
            const clampedY = Math.round(Math.max(0, Math.min(y, imageCanvas.height - 1)));

            // Get pixel data for color display
            const imageData = ctx.getImageData(clampedX, clampedY, 1, 1).data;
            const r = imageData[0]; // Red component
            const g = imageData[1]; // Green component
            const b = imageData[2]; // Blue component

            updateColorDisplay(r, g, b);

            // --- Magnifier Logic ---
            // Calculate source region for magnifier
            // Center the source region around the *exact* pixel being picked
            const sx = clampedX - Math.floor(SOURCE_REGION_SIZE / 2);
            const sy = clampedY - Math.floor(SOURCE_REGION_SIZE / 2);

            // Clear magnifier canvas
            magnifierCtx.clearRect(0, 0, MAGNIFIER_SIZE, MAGNIFIER_SIZE);

            // Draw the magnified image portion with pixelated scaling
            magnifierCtx.drawImage(
                imageCanvas,
                sx, sy, SOURCE_REGION_SIZE, SOURCE_REGION_SIZE, // Source rectangle on imageCanvas
                0, 0, MAGNIFIER_SIZE, MAGNIFIER_SIZE // Destination rectangle on magnifierCanvas
            );

            // Draw a red square in the center to highlight the sampled pixel
            const centerPixelSize = MAGNIFICATION_FACTOR; // The size of one magnified pixel
            const centerOffset = (MAGNIFIER_SIZE / 2) - (centerPixelSize / 2); // Center the square
            magnifierCtx.fillStyle = 'red';
            magnifierCtx.fillRect(centerOffset, centerOffset, centerPixelSize, centerPixelSize);

            // Draw crosshairs that align with the grid and center on the highlighted pixel
            magnifierCtx.strokeStyle = 'red';
            magnifierCtx.lineWidth = 1;
            magnifierCtx.beginPath();
            // Horizontal line
            magnifierCtx.moveTo(0, MAGNIFIER_SIZE / 2);
            magnifierCtx.lineTo(MAGNIFIER_SIZE, MAGNIFIER_SIZE / 2);
            // Vertical line
            magnifierCtx.moveTo(MAGNIFIER_SIZE / 2, 0);
            magnifierCtx.lineTo(MAGNIFIER_SIZE / 2, MAGNIFIER_SIZE);
            magnifierCtx.stroke();


            // Position the magnifier
            // Adjust position to keep it from going off-screen and to be slightly offset from cursor
            const magnifierOffsetX = 20; // Offset from cursor
            const magnifierOffsetY = 20;

            let newLeft = event.clientX + magnifierOffsetX;
            let newTop = event.clientY + magnifierOffsetY;

            // Keep magnifier within window bounds
            if (newLeft + MAGNIFIER_SIZE > window.innerWidth) {
                newLeft = event.clientX - MAGNIFIER_SIZE - magnifierOffsetX;
            }
            if (newTop + MAGNIFIER_SIZE > window.innerHeight) {
                newTop = event.clientY - MAGNIFIER_SIZE - magnifierOffsetY;
            }

            magnifier.style.left = `${newLeft}px`;
            magnifier.style.top = `${newTop}px`;
            magnifier.style.display = 'block'; // Show magnifier
        }

        // Attach mouse event listeners to the canvas
        imageCanvas.addEventListener('mousemove', getPixelColorAndMagnify);
        imageCanvas.addEventListener('click', getPixelColorAndMagnify); // Also pick on click for mobile/precision

        imageCanvas.addEventListener('mouseenter', () => {
            if (currentImage) {
                magnifier.style.display = 'block';
            }
        });

        imageCanvas.addEventListener('mouseleave', () => {
            magnifier.style.display = 'none';
        });

        // Function to update the color display elements
        function updateColorDisplay(r, g, b) {
            const hex = rgbToHex(r, g, b);
            const rgb = `rgb(${r}, ${g}, ${b})`;
            const hsl = rgbToHsl(r, g, b);

            colorBox.style.backgroundColor = hex;
            hexValue.textContent = hex;
            rgbValue.textContent = rgb;
            hslValue.textContent = hsl;
        }

        // Utility function to convert RGB to Hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        // Utility function to convert RGB to HSL
        // Adapted from https://css-tricks.com/converting-color-formats/
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            let cmin = Math.min(r, g, b),
                cmax = Math.max(r, g, b),
                delta = cmax - cmin,
                h = 0,
                s = 0,
                l = 0;

            if (delta === 0)
                h = 0;
            // Red is max
            else if (cmax === r)
                h = ((g - b) / delta) % 6;
            // Green is max
            else if (cmax === g)
                h = (b - r) / delta + 2;
            // Blue is max
            else
                h = (r - g) / delta + 4;

            h = Math.round(h * 60);

            // Make negative hues positive
            if (h < 0)
                h += 360;

            l = (cmax + cmin) / 2;

            // Calculate saturation
            s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));

            // Multiply l and s by 100
            s = +(s * 100).toFixed(1);
            l = +(l * 100).toFixed(1);

            return `hsl(${h}, ${s}%, ${l}%)`;
        }

        // Function to copy text content to clipboard
        function copyToClipboard(elementId) {
            const textToCopy = document.getElementById(elementId).textContent;
            const tempInput = document.createElement('textarea'); // Use textarea for better compatibility
            tempInput.value = textToCopy;
            document.body.appendChild(tempInput);
            tempInput.select();
            try {
                document.execCommand('copy');
                showMessage('Copied to clipboard!');
            } catch (err) {
                showMessage('Failed to copy!', 'error');
                console.error('Failed to copy text: ', err);
            } finally {
                document.body.removeChild(tempInput);
            }
        }

        // Handle drag and drop for image upload
        const uploadArea = document.querySelector('.upload-area');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('border-indigo-500', 'bg-indigo-50');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('border-indigo-500', 'bg-indigo-50');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('border-indigo-500', 'bg-indigo-50');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                imageUpload.files = files; // Assign dropped files to the input
                imageUpload.dispatchEvent(new Event('change')); // Trigger change event
            }
        });

        // Initial state: set default color display
        updateColorDisplay(204, 204, 204); // Default gray
    </script>
</body>
</html>
